layout:              post
title:               "模块化开发文档"
subtitle:            " \"模块化开发文档\""
description:         "模块化开发文档"
date:                2018-04-01 00:00:00 +0800
author:              "SNLO"
header-img:          "img/header_code.jpg"
catalog:             true
tags:

- 文档

# SNModuleKit模块化规范

> 本文是针对`SNModuleKit`框架下的模块化架构做出的规范



## 关键术语说明

### 模块

- 模块，module，模块是一个通用概念，**可能从功能或其他目的来区分**。模块可以是子系统子领域，主要取决于上下文环境的用法。通常我们会说程序模块，功能模块，这实际上是在按照不同的标准对模块的内容和范围的不同定义。
- 通常我们说的程序模块，是指的一段能够实现某个有价值目标的的成员代码段，这样的东西，我们还有另一个称呼：例程，而例程有两种，即函数和过程，它们都能实现一个有价值的目标供其它的模块使用。
- 而功能模块的说法一般在分析和设计阶段出现得比较频繁，通常我们用一个功能模块来说明一个功能所包含的系统行为，当我们觉得分析的颗粒度可能更大一些的时候我们可以用一个功能模块来表示一组功能的集合，这似乎让我们觉得，模块这个词的概念和“子系统”这个词的概念有些模糊，是的，事实上，有些大的模块会慢慢的让我们觉得称呼他们子系统更合适，或者一个子系统，我们会慢慢发现你还包含着一些模块。
- 但是无论怎样，**定义模块的原则应该是：高内聚和低耦合。**
- 使用方法：就是一个描述全局中问题的概念，至于全局是什么，这个随便，比如一个人，可以看成各种功能系统，那么模块就是各种呼吸系统、消化系统等；可以看成社会关系，模块就有劳动能力、生产关系等，全在于怎么看了。

### 组件

- 组件，Component，首先说，组件已经不是一个抽线的概念了，**是封装了一个或多个实体程序模块的实体。**
- 组件这个词通常是现在描述产品的时候出现，一个大的产品会有很多小的部分组成，而小的部分除了是一个大的组件的部分以外，自己可能还包含更小的组件，所以**组件是递归的**，那么组件到底是什么呢？最常见的组件就是我们已经写好的程序代码，任何一小段代码都可以是一个组件，它可以和其它代码段连接起来组成更大的一段程序代码，一个更大的组件，然后可能是一个函数，或者一个类程序单元，或者数个类单元文件的集成，当不同的组件的组装形成更大的组件时候，我们实际就是在做我们通常提到的一件事情：集成，软件中有很多集成工作要做，每日集成，重要版本集成等等，集成是什么呢？软件中，就是链编调试。这样一来，我们知道集成是需要对被集成的组件有规模要求的，换句话说，至少是一个单元文件，所以通常说到的组件就可以直观的理解为单元文件，或者可以组成软件的其他文件，以及编译后的文件。
- **组件是面向对象里面的一个重用的概念，也称为构件**，组件非常类似机械中构件概念，现在机械都是走向构件生成，通过不同构件组装成一个机械成品，软件目前也是这样的一个生成方式。
- 维基百科上说，组件之间通过接口进行交互，这个挺起来有些象插件，现实中也是这样，比如一个dll文件，可以说是插件，也可以说是组件。插件是是组件的一个子类，就是将组件中具有某些特点的组件归为插件，这些特点是：益于与系统分离，接口明晰，可以替换的程序模块。
- 组件强调的是封装，利用接口进行交互。因为封装有不同层次的封装，对应不同层次的接口，（比如将一个人封装成一个组件，比如国家主席，多个人封装成一个组合，比如中央的常委们），所以组件所表述的范围和层次也是多种多样的，**在谈论组件的时候一定要分辨清楚谈论的层次和范围**。层次是相对的。你说地球是整个世界，但是将地球放到银河系中，地球就显得渺小了；你说物质世界是整个世界，但是人类的精神世界也是无比的浩瀚；你说物质世界和精神世界合起来是整个世界，但是历史又是那么的神秘和真实；你说物质世界、精神世界、历史时空是整个世界，但是科学家又说人类可以探察的宇宙物质仅占全部宇宙的百分之四。
- 使用方法：就是一个描述系统中实体单元的概念。

### 插件

- 根据对组件和模块的分析，**插件属于组件，而且还是一个程序模块，也是一个功能模块。**插件是一种电脑程序，通过和应用程序的互动，来替应用程式增加一些特定的功能。 **插件必须依赖于应用程序才能发挥自身功能，仅靠插件是无法正常运行的。**
- 使用方法：**满足一定接口规范的具有一定功能的程序模块**。开发者可以在自己软件系统中设计相应的接口以匹配某个插件，也可以设计一定的接口规范，来让别人开发插件。插件和程序之间通过接口进行交互。

### 控件

- 可视化的组件。比如`UIViewController`、`SNPopupView`和`UITableview`等。

### 中间件

- 中间件是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。

### 内聚

- 块内联系

- 模块内部各组成成分之间相互联系的强度。

### 耦合

- 块间联系

- 模块之间的依赖程度的度量，是模块独立性的直接衡量。包括紧密耦合、松散耦合
  及无耦合。

## 什么是模块化

按一定原则将软件划分成若干个模块，使每个模块完成一个子功能，然后将这些模块组装起来就可以完成系统要求的功能，这个过程就是模块化。模块化的目的是降低系统复杂性。

为什么说模块化而不是组件化呢？本文认为，模块是组件的超集，模块中也许包含许多个组件，而一个复杂的系统如果只有组件化的存在，那可能存在N多个组件，系统依然复杂。如果把耦合度高的一些组件组合在一起，也就自然形成了模块。如果系统依然复杂，模块也会依然多？其实不然，模块的组成是随系统研发的生命周期而产生的，当周期为初期时，可能模块相对较大数目较少。随则周期的推进，可能模块会被细化数目增多，这并不会影响系统，因为模块被设计的原则就是高内聚低耦合，严格来说，一个模块不会对另一个模块产生副作用。

## 为什么要实施模块化开发

当系统复杂度很高时，我们有必要在架构层面上去降低这种复杂性。那我们实施模块化，将各个不同的功能拆分开，或者根据某些约定的原则拆分，将重复相同的部分合并起来，此时组成的模块与模块间是低耦合的，模块内是高内聚的。这种架构及其便利团队开发，团队中各个成员负责不同的模块，他们不再过多的相互干扰。对于那些都需要使用到的部分都被合并到了同个模块里，不会再彼此考虑相同的事情而产生不同的结论。这种模式有利于团队的开发效率，并且当某个功能或子系统模块出了问题，可以快速的进行替换，可以想象一下补丁。

下面来罗列下模块化的优势：

- 独立性，模块内高内聚，模块间低耦合
- 高效性，符合团队高效开发，可实现单个模块独立运行
- 易维护，易测试
- 复用性，模块间可实现资源共享
- 信息隐蔽，模块作用范围由模块内部决定
- 灵活性，模块的细腻程度由系统生命周期决定

## 在`SNModuleKit`框架下，模块化是怎么实施的

先来看看`SNModuleKit`本身的架构图：



## 模块化编码规范

## 目录

- [模块目录结构](#模块目录结构)
- [模块开发相关规范](#模块开发相关规范)
- [关于中间调度](#关于中间调度)
- [第三方库](#第三方库)
- [模块内业务代码组织结构](#模块内业务代码组织结构)
- [团队编码指南](#团队编码指南)
- [关于](#关于)

## 模块目录结构



## 模块开发相关规范

1. 在模块中可以使用MVC、MVVM、MVP等常用开发框架，因为每个模块之间都是相互独立的，耦合度几乎为零，它们仅因中间调度者‘mediator’的存在而相互有着联系。

2. 在模块中，类名以及文件名的命名规范如一下格式：

   ```objective-c
   //类名文件名 = 模块名+创建者标识（若该模块只是独立开发可忽略）+业务定义+所属属性
   /**
   ps: OrderBaseViewController = Order(模块名) + Base(定义) + ViewController(属性为视图控制器)；
   */
   ```

3. 命名当以美式英语加驼峰的形式进行，如需另行说明可在相应头文件中注释。不得出现‘[图一]’中的情况。

4. 所有业务代码必须对号入座，如不能在工具类文件夹中存放宏定义文件等。

5. 对于UIViewController的创建方式非特殊需求禁止采用懒加载的方式创建。以此来防止不必要的循环引用。

## 关于中间调度

由`SNMediatorKit`中间件所决定的，模块间`Target-Action`的规范

1. 调度是以target-action的方式进行的，在SNMediator分类中进行并带有参数params 如‘SNMediator+OrderActions’中，在Target_中实现。

2. SNMediator的调度顺序：远程调度 —> 本地调度。所以在各模块中只有本地调度。若有远程调度的需求，也没关系，因为始终都会到达本地调度这一步。

3. 在对中间调度进行开发时，需注意几处硬编码。这也是为了避免调度开始前的中间件注册问题。硬编码说明如下：

   ```objective-c
   # import "Target_Order.h" // 'Target_ + target名一般情况以模块名命名’ 中 ‘Target_’为硬编码
   
   # import "OrderBaseViewController.h"
   
   @implementation Target_kOrder
   /**
    方法名中‘Action_’为硬编码，‘Action_native...’中除了‘Action_’硬编码外‘native’也算是，因为‘native’是为了区分远程调度而存在的硬编码。
    */
   
   - (UIViewController *)Action_nativeFetchOrderBaseViewController:(NSDictionary *)parames {
   
     OrderBaseViewController * VC = [[OrderBaseViewController alloc] init];
     return VC;
     }
   @end
   ```

   ```objective-c
   # import "SNMediator+OrderActions.h"
   
   //Actions中 类‘Target_’之后的硬编码
   NSString * const kSNMediatorTargetOrderAction = @"kOrder";
   
   //Actions中 方法'Action_'之后的硬编码
   NSString * const kSNMediatorActionNativeFetchOrderBasrViewController = @"nativeFetchOrderBaseViewController";
   
   @implementation SNMediator (OrderActions)
   
   - (UIViewController *)SNMediator_viewControllerForOrderBase:(NSDictionary *)params {
   
     UIViewController * viewController = [[SNMediator sharedManager] performTarget:kSNMediatorTargetOrderAction action:kSNMediatorActionNativeFetchOrderBasrViewController params:params shouldCacheTarget:NO];
   
     if ([viewController isKindOfClass:[UIViewController class]]) {
       return viewController;
     } else {
       UIViewController * nullViewController = [UIViewController new];
       [nullViewController.view sn_viewEmpty];
       return nullViewController;
     }
     }
   
   @end
   ```

   ​

## 第三方库

1. 模块内采用手动管理的方式集中在‘vender’中管理。不能使用cocoapods管理，当第三方库出现在了模块中，则说明该第三方库对其他模块意义不大，相反则表明该组件化架构有待优化。
2. 尽量避免在第三方库中修改其源码，有必要时可与源码作者沟通。
3. 在本地导入第三方库前，请参考公共组件模块，避免重复导入造成不必要的麻烦，或者与小组成员谈论该第三方库的可用性。

## 模块内业务代码组织结构

1. 模块内关于业务相关的开发框架没有限制，但是尽量与其它的模块风格保持一致。代码

   1. 目录结构应该是 业务—>框架 的强业务型 如下图：   

      ![屏幕快照 2017-10-27 下午1.50.51](/Users/snlo/Desktop/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-27%20%E4%B8%8B%E5%8D%881.50.51.png)		

    而不是 框架—>业务，如下图：

    ![屏幕快照 2017-10-27 下午4.07.51](/Users/snlo/Desktop/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-27%20%E4%B8%8B%E5%8D%884.07.51.png)	



1. 建议采用XIB而不是storyboard。

2. 创建Controller时采用自定义的snlo touch class，里面有代码管理规范的Mark

   ​

## 编码规范

1. 命名应尽可能遵守Apple命名约定，特别是与[内存管理规则](https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html)（[NARC](http://stackoverflow.com/a/2865194/340508)）有关的命名约定。命名长的，描述性的方法和变量名很好。

2. 对变量属性的命名和声明应该是(采用反命名规则，如应该是buttonSetting而不是settingButton，再如果应该是viewPerson而不是personView)：

   ```objective-c
   @property (nonatomic, strong) UIButton * buttonSetting;
   
   self.buttonSetting;
   
   #pragma mark -- getter / setter
   - (UIButton *)buttonSetting {
       if (!_buttonSetting) {
           _buttonSetting = [UIButton buttonWithType:UIButtonTypeSystem];
       } return _buttonSetting;
   }
   ```

   而不应该是：

   ```objective-c
   @interface StandardViewController () <UITableViewDelegate> {
       UIButton * _setBut;
   }
   
   _setBut;
   ```

3. 注释：当需要它们时，应该使用注释来解释**为什么**特定的代码片段做某事。注释必须保持最新。通常应避免阻止注释，因为代码应尽可能自我记录，只需要间歇的，几行的解释。所有暴露在头文件里面的必须注释。

4. 间距：应该是：

   ```objective-c
   if（user.isHappy）{
      //做某事 
   } else {
      //做别的事情 
   }
   
   //块很容易读取 
   [UIView animateWithDuration:3.0f animations:^{
     // something
   } completion:^(BOOL finished) {
     // something
   }];
   ```

   而不应该是：

   ```objective-c
   if（user.isHappy）{
      //做某事 
   } 
   else {
      //做别的事情 
   }
   
   //块很容易读取 ，不应该提行！
       [UIView animateWithDuration:3.0f
                        animations:^{
                            // something
       }
                        completion:^(BOOL finished) {
                            // something
       }];
   ```

5. 命名优先级（相对本模块）：

   ```objective-c
   object name = module name + developer name + object definition + object attribute;
   ```

   ​

6. 对API的命名要求：
   如果是系统或者第三方库的分类的属性或者接口的命名必须添加类似‘sn_’的前缀。
   其它的应该尽量言简意赅。（可以参考apple的格式）

## 关于

1. 每个模块都将依赖于 ‘SNModuleKit’基础组件模块

