layout:              post
title:               "模块化开发文档"
subtitle:            " \"模块化开发文档\""
description:         "模块化开发文档"
date:                2018-04-01 00:00:00 +0800
author:              "SNLO"
header-img:          "img/header_code.jpg"
catalog:             true
tags:

- 文档

# 模块化规范

**针对组件化的架构下对模块开发的一些规范**

## 目录

- [模块目录结构](#模块目录结构)
- [模块开发相关规范](#模块开发相关规范)
- [关于中间调度](#关于中间调度)
- [第三方库](#第三方库)
- [模块内业务代码组织结构](#模块内业务代码组织结构)
- [团队编码指南](#团队编码指南)
- [关于](#关于)

## 模块目录结构



## 模块开发相关规范

1. 在模块中可以使用MVC、MVVM、MVP等常用开发框架，因为每个模块之间都是相互独立的，耦合度几乎为零，它们仅因中间调度者‘mediator’的存在而相互有着联系。

2. 在模块中，类名以及文件名的命名规范如一下格式：

   ```objective-c
   //类名文件名 = 模块名+创建者标识（若该模块只是独立开发可忽略）+业务定义+所属属性
   /**
   ps: OrderBaseViewController = Order(模块名) + Base(定义) + ViewController(属性为视图控制器)；
   */
   ```

3. 命名当以美式英语加驼峰的形式进行，如需另行说明可在相应头文件中注释。不得出现‘[图一]’中的情况。

4. 所有业务代码必须对号入座，如不能在工具类文件夹中存放宏定义文件等。

5. 对于UIViewController的创建方式非特殊需求禁止采用懒加载的方式创建。以此来防止不必要的循环引用。

## 关于中间调度

1. 调度是以target-action的方式进行的，在SNMediator分类中进行并带有参数params 如‘SNMediator+OrderActions’中，在Target_中实现。

2. SNMediator的调度顺序：远程调度 —> 本地调度。所以在各模块中只有本地调度。若有远程调度的需求，也没关系，因为始终都会到达本地调度这一步。

3. 在对中间调度进行开发时，需注意几处硬编码。这也是为了避免调度开始前的中间件注册问题。硬编码说明如下：

   ```objective-c
   # import "Target_Order.h" // 'Target_ + target名一般情况以模块名命名’ 中 ‘Target_’为硬编码
   
   # import "OrderBaseViewController.h"
   
   @implementation Target_kOrder
   /**
    方法名中‘Action_’为硬编码，‘Action_native...’中除了‘Action_’硬编码外‘native’也算是，因为‘native’是为了区分远程调度而存在的硬编码。
    */
   
   - (UIViewController *)Action_nativeFetchOrderBaseViewController:(NSDictionary *)parames {
   
     OrderBaseViewController * VC = [[OrderBaseViewController alloc] init];
     return VC;
     }
   @end
   ```

   ```objective-c
   # import "SNMediator+OrderActions.h"
   
   //Actions中 类‘Target_’之后的硬编码
   NSString * const kSNMediatorTargetOrderAction = @"kOrder";
   
   //Actions中 方法'Action_'之后的硬编码
   NSString * const kSNMediatorActionNativeFetchOrderBasrViewController = @"nativeFetchOrderBaseViewController";
   
   @implementation SNMediator (OrderActions)
   
   - (UIViewController *)SNMediator_viewControllerForOrderBase:(NSDictionary *)params {
   
     UIViewController * viewController = [[SNMediator sharedManager] performTarget:kSNMediatorTargetOrderAction action:kSNMediatorActionNativeFetchOrderBasrViewController params:params shouldCacheTarget:NO];
   
     if ([viewController isKindOfClass:[UIViewController class]]) {
       return viewController;
     } else {
       UIViewController * nullViewController = [UIViewController new];
       [nullViewController.view sn_viewEmpty];
       return nullViewController;
     }
     }
   
   @end
   ```

   ​

## 第三方库

1. 模块内采用手动管理的方式集中在‘vender’中管理。不能使用cocoapods管理，当第三方库出现在了模块中，则说明该第三方库对其他模块意义不大，相反则表明该组件化架构有待优化。
2. 尽量避免在第三方库中修改其源码，有必要时可与源码作者沟通。
3. 在本地导入第三方库前，请参考公共组件模块，避免重复导入造成不必要的麻烦，或者与小组成员谈论该第三方库的可用性。

## 模块内业务代码组织结构

1. 模块内关于业务相关的开发框架没有限制，但是尽量与其它的模块风格保持一致。代码

   1. 目录结构应该是 业务—>框架 的强业务型 如下图：   

      ![屏幕快照 2017-10-27 下午1.50.51](/Users/snlo/Desktop/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-27%20%E4%B8%8B%E5%8D%881.50.51.png)		

    而不是 框架—>业务，如下图：

    ![屏幕快照 2017-10-27 下午4.07.51](/Users/snlo/Desktop/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-27%20%E4%B8%8B%E5%8D%884.07.51.png)	



1. 建议采用XIB而不是storyboard。

2. 创建Controller时采用自定义的snlo touch class，里面有代码管理规范的Mark

   ​

## 编码规范

1. 命名应尽可能遵守Apple命名约定，特别是与[内存管理规则](https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html)（[NARC](http://stackoverflow.com/a/2865194/340508)）有关的命名约定。命名长的，描述性的方法和变量名很好。

2. 对变量属性的命名和声明应该是(采用反命名规则，如应该是buttonSetting而不是settingButton，再如果应该是viewPerson而不是personView)：

   ```objective-c
   @property (nonatomic, strong) UIButton * buttonSetting;
   
   self.buttonSetting;
   
   #pragma mark -- getter / setter
   - (UIButton *)buttonSetting {
       if (!_buttonSetting) {
           _buttonSetting = [UIButton buttonWithType:UIButtonTypeSystem];
       } return _buttonSetting;
   }
   ```

   而不应该是：

   ```objective-c
   @interface StandardViewController () <UITableViewDelegate> {
       UIButton * _setBut;
   }
   
   _setBut;
   ```

3. 注释：当需要它们时，应该使用注释来解释**为什么**特定的代码片段做某事。注释必须保持最新。通常应避免阻止注释，因为代码应尽可能自我记录，只需要间歇的，几行的解释。所有暴露在头文件里面的必须注释。

4. 间距：应该是：

   ```objective-c
   if（user.isHappy）{
      //做某事 
   } else {
      //做别的事情 
   }
   
   //块很容易读取 
   [UIView animateWithDuration:3.0f animations:^{
     // something
   } completion:^(BOOL finished) {
     // something
   }];
   ```

   而不应该是：

   ```objective-c
   if（user.isHappy）{
      //做某事 
   } 
   else {
      //做别的事情 
   }
   
   //块很容易读取 ，不应该提行！
       [UIView animateWithDuration:3.0f
                        animations:^{
                            // something
       }
                        completion:^(BOOL finished) {
                            // something
       }];
   ```

   ​

5. 命名优先级（相对本模块）：

   ```objective-c
   object name = module name + developer name + object definition + object attribute;
   ```

   ​

6. 对API的命名要求：
   如果是系统或者第三方库的分类的属性或者接口的命名必须添加类似‘sn_’的前缀。
   其它的应该尽量言简意赅。（可以参考apple的格式）

## 关于

1. 每个模块都将依赖于 ‘SNModuleKit’基础组件模块

