layout:              post
title:               "模块化开发文档"
subtitle:            " \"模块化开发文档\""
description:         "模块化开发文档"
date:                2018-04-01 00:00:00 +0800
author:              "SNLO"
header-img:          "img/header_code.jpg"
catalog:             true
tags:

- 文档

# SNModuleKit模块化规范

> 本文是针对`SNModuleKit`框架下的模块化架构做出的规范



## 关键术语说明

### 模块

- 模块，module，模块是一个通用概念，**可能从功能或其他目的来区分**。模块可以是子系统子领域，主要取决于上下文环境的用法。通常我们会说程序模块，功能模块，这实际上是在按照不同的标准对模块的内容和范围的不同定义。
- 通常我们说的程序模块，是指的一段能够实现某个有价值目标的的成员代码段，这样的东西，我们还有另一个称呼：例程，而例程有两种，即函数和过程，它们都能实现一个有价值的目标供其它的模块使用。
- 而功能模块的说法一般在分析和设计阶段出现得比较频繁，通常我们用一个功能模块来说明一个功能所包含的系统行为，当我们觉得分析的颗粒度可能更大一些的时候我们可以用一个功能模块来表示一组功能的集合，这似乎让我们觉得，模块这个词的概念和“子系统”这个词的概念有些模糊，是的，事实上，有些大的模块会慢慢的让我们觉得称呼他们子系统更合适，或者一个子系统，我们会慢慢发现你还包含着一些模块。
- 但是无论怎样，**定义模块的原则应该是：高内聚和低耦合。**
- 使用方法：就是一个描述全局中问题的概念，至于全局是什么，这个随便，比如一个人，可以看成各种功能系统，那么模块就是各种呼吸系统、消化系统等；可以看成社会关系，模块就有劳动能力、生产关系等，全在于怎么看了。

### 组件

- 组件，Component，首先说，组件已经不是一个抽线的概念了，**是封装了一个或多个实体程序模块的实体。**
- 组件这个词通常是现在描述产品的时候出现，一个大的产品会有很多小的部分组成，而小的部分除了是一个大的组件的部分以外，自己可能还包含更小的组件，所以**组件是递归的**，那么组件到底是什么呢？最常见的组件就是我们已经写好的程序代码，任何一小段代码都可以是一个组件，它可以和其它代码段连接起来组成更大的一段程序代码，一个更大的组件，然后可能是一个函数，或者一个类程序单元，或者数个类单元文件的集成，当不同的组件的组装形成更大的组件时候，我们实际就是在做我们通常提到的一件事情：集成，软件中有很多集成工作要做，每日集成，重要版本集成等等，集成是什么呢？软件中，就是链编调试。这样一来，我们知道集成是需要对被集成的组件有规模要求的，换句话说，至少是一个单元文件，所以通常说到的组件就可以直观的理解为单元文件，或者可以组成软件的其他文件，以及编译后的文件。
- **组件是面向对象里面的一个重用的概念，也称为构件**，组件非常类似机械中构件概念，现在机械都是走向构件生成，通过不同构件组装成一个机械成品，软件目前也是这样的一个生成方式。
- 维基百科上说，组件之间通过接口进行交互，这个挺起来有些象插件，现实中也是这样，比如一个dll文件，可以说是插件，也可以说是组件。插件是是组件的一个子类，就是将组件中具有某些特点的组件归为插件，这些特点是：益于与系统分离，接口明晰，可以替换的程序模块。
- 组件强调的是封装，利用接口进行交互。因为封装有不同层次的封装，对应不同层次的接口，（比如将一个人封装成一个组件，比如国家主席，多个人封装成一个组合，比如中央的常委们），所以组件所表述的范围和层次也是多种多样的，**在谈论组件的时候一定要分辨清楚谈论的层次和范围**。层次是相对的。你说地球是整个世界，但是将地球放到银河系中，地球就显得渺小了；你说物质世界是整个世界，但是人类的精神世界也是无比的浩瀚；你说物质世界和精神世界合起来是整个世界，但是历史又是那么的神秘和真实；你说物质世界、精神世界、历史时空是整个世界，但是科学家又说人类可以探察的宇宙物质仅占全部宇宙的百分之四。
- 使用方法：就是一个描述系统中实体单元的概念。

### 插件

- 根据对组件和模块的分析，**插件属于组件，而且还是一个程序模块，也是一个功能模块。**插件是一种电脑程序，通过和应用程序的互动，来替应用程式增加一些特定的功能。 **插件必须依赖于应用程序才能发挥自身功能，仅靠插件是无法正常运行的。**
- 使用方法：**满足一定接口规范的具有一定功能的程序模块**。开发者可以在自己软件系统中设计相应的接口以匹配某个插件，也可以设计一定的接口规范，来让别人开发插件。插件和程序之间通过接口进行交互。

### 控件

- 可视化的组件。比如`UIViewController`、`SNPopupView`和`UITableview`等。

### 中间件

- 中间件是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。

### 内聚

- 块内联系

- 模块内部各组成成分之间相互联系的强度。

### 耦合

- 块间联系

- 模块之间的依赖程度的度量，是模块独立性的直接衡量。包括紧密耦合、松散耦合
  及无耦合。

## 什么是模块化

按一定原则将软件划分成若干个模块，使每个模块完成一个子功能，然后将这些模块组装起来就可以完成系统要求的功能，这个过程就是模块化。模块化的目的是降低系统复杂性。

为什么说模块化而不是组件化呢？本文认为，模块是组件的超集，模块中也许包含许多个组件，而一个复杂的系统如果只有组件化的存在，那可能存在N多个组件，系统依然复杂。如果把耦合度高的一些组件组合在一起，也就自然形成了模块。如果系统依然复杂，模块也会依然多？其实不然，模块的组成是随系统研发的生命周期而产生的，当周期为初期时，可能模块相对较大数目较少。随则周期的推进，可能模块会被细化数目增多，这并不会影响系统，因为模块被设计的原则就是高内聚低耦合，严格来说，一个模块不会对另一个模块产生副作用。

## 为什么要实施模块化开发

当系统复杂度很高时，我们有必要在架构层面上去降低这种复杂性。那我们实施模块化，将各个不同的功能拆分开，或者根据某些约定的原则拆分，将重复相同的部分合并起来，此时组成的模块与模块间是低耦合的，模块内是高内聚的。这种架构及其便利团队开发，团队中各个成员负责不同的模块，他们不再过多的相互干扰。对于那些都需要使用到的部分都被合并到了同个模块里，不会再彼此考虑相同的事情而产生不同的结论。这种模式有利于团队的开发效率，并且当某个功能或子系统模块出了问题，可以快速的进行替换，可以想象一下补丁。

下面来罗列下模块化的优势：

- 独立性，模块内高内聚，模块间低耦合
- 高效性，符合团队高效开发，可实现单个模块独立运行
- 易维护，易测试
- 复用性，模块间可实现资源共享
- 信息隐蔽，模块作用范围由模块内部决定
- 灵活性，模块的细腻程度由系统生命周期决定

## 在`SNModuleKit`框架下，模块化是怎么实施的

先来看看`SNModuleKit`本身的架构图：![1](/Users/snlo/Desktop/gitHub/snlo.github.io/img/blog_img/180401/1.jpg)

SNModuleKit在Github上开源，<a href= "https://github.com/snlo/SNModuleKit" target="_blank">这里</a>有详细的介绍和使用说明。

首先导入框架，可以通过依赖管理工具导入。再使用框架中提供的模块模板工具创建新的模块，项目的模块化就开始了。

在模块化开始之前需要考虑的事：模块怎么划分。这个非常重要，划分恰当会直接减少之后模块拆分的工作难度，当然模块拆分我认为是避免不了的，因为模块的粒度总是由大到小你始终不确定未来会发生什么。在做模块划分的时候至少会考虑一下几个因数：

1. 模块化实施前项目所处的阶段。
2. 团队规模，各个团队成员各自的强项。
3. 各个端口的情况，比如产品经理、后端和前端等。
4. 项目未来整体大致的规划。
5. 模块的各个组成部分应尽量准守`开-闭`原则（设计模式几大原则之首）。

为什么要考虑这些个因数呢？那如果说项目在初期阶段，各模块被划分得比较大的话，在项目研发进行到一定程度，或者说需求累积到一定量时，整个模块内的业务量会大到让人头痛，以至于模块化都不复存在了，并且当对这种“超级”模块进行模块拆分时，会让你感觉浑身不舒服。

为什么要考虑模块化实施前项目所处的阶段呢？项目在不同的阶段，实施模块化都是不一样的。我们就拿简单的项目生命周期来说事：

1. 规划阶段
2. 计划阶段
3. 实施阶段（研发阶段）
4. 完成阶段（维护阶段）

在阶段1和2的时候，尽量参与进入，参与不了的后期也要多分析他们梳理出来的文档。这样做的好处是你会预判整个项目未来具体长啥样子。既是心中有数也是具有全局观，模块划分才会有方向感，不至于把两个完全不相关的功能或者组件放到一个模块里，违背了“高内聚、低耦合”的设计原则。在阶段3的时候，如果之前就做好了模块化，那么这个阶段模块很有可能会增多会变小。当两人同时开发一个模块的时候，是时候考虑进行模块拆分了，拆分后各自负责各自负责的模块，互不干扰。如果在此之前没有进行模块化，也就是说是在项目研发到一半时才开始模块化，不要慌张，其实也很简单，只是一些模块拆分和重组类似的工作，不就是项目架构重构嘛，请自己相信自己，为了项目将来的发展。在阶段4的时候，项目需求已经趋于完善了相对稳定，这时有必要考虑从新审查每个模块，让它们接近完美。为以后的维护做准备，为项目突然新增需求做准备，比如说不就是新增加一个扫描二维码的功能嘛，好的完成了，在产品部刚出需求变更通知时。再比如某个模块出问题了，没关系立马用备用模块临时替换掉。审查每个模块朝着这种“比如”去做就对了。

为什么要考虑模团队成员各自的强项呢？很简单，举个例子说明，团队中分别有小明和小花两名成员，小明擅长视频处理，小花擅长图形图像处理，，，

为什么要考虑项目未来整体大致的规划呢？其实说白就是到底要不要模块化？要知道不是所有的项目都适合去做模块化，到底适不适合？各有各的说法仁者见仁，非要强行在只有一个单一功能的小项目中实施模块化谁又能说什么呢。再比如，团队中这个端口就只有一个人，并且根据项目规划，未来不打算增加团队成员，这种情概况进行模块化，我觉得那个人实属不易。要知道模块化还是会增加不少的工作量的。

## 模块化编码规范

## 目录

- [模块目录结构](#模块目录结构)
- [模块开发相关规范](#模块开发相关规范)
- [关于中间调度](#关于中间调度)
- [第三方库](#第三方库)
- [模块内业务代码组织结构](#模块内业务代码组织结构)
- [团队编码指南](#团队编码指南)
- [关于](#关于)

## 模块目录结构



## 模块开发相关规范

1. 在模块中可以使用MVC、MVVM、MVP等常用开发框架，因为每个模块之间都是相互独立的，耦合度几乎为零，它们仅因中间调度者‘mediator’的存在而相互有着联系。

2. 在模块中，类名以及文件名的命名规范如一下格式：

   ```objective-c
   //类名文件名 = 模块名+创建者标识（若该模块只是独立开发可忽略）+业务定义+所属属性
   /**
   ps: OrderBaseViewController = Order(模块名) + Base(定义) + ViewController(属性为视图控制器)；
   */
   ```

3. 命名当以美式英语加驼峰的形式进行，如需另行说明可在相应头文件中注释。不得出现‘[图一]’中的情况。

4. 所有业务代码必须对号入座，如不能在工具类文件夹中存放宏定义文件等。

5. 对于UIViewController的创建方式非特殊需求禁止采用懒加载的方式创建。以此来防止不必要的循环引用。

## 关于中间调度

由`SNMediatorKit`中间件所决定的，模块间`Target-Action`的规范

1. 调度是以target-action的方式进行的，在SNMediator分类中进行并带有参数params 如‘SNMediator+OrderActions’中，在Target_中实现。

2. SNMediator的调度顺序：远程调度 —> 本地调度。所以在各模块中只有本地调度。若有远程调度的需求，也没关系，因为始终都会到达本地调度这一步。

3. 在对中间调度进行开发时，需注意几处硬编码。这也是为了避免调度开始前的中间件注册问题。硬编码说明如下：

   ```objective-c
   # import "Target_Order.h" // 'Target_ + target名一般情况以模块名命名’ 中 ‘Target_’为硬编码
   
   # import "OrderBaseViewController.h"
   
   @implementation Target_kOrder
   /**
    方法名中‘Action_’为硬编码，‘Action_native...’中除了‘Action_’硬编码外‘native’也算是，因为‘native’是为了区分远程调度而存在的硬编码。
    */
   
   - (UIViewController *)Action_nativeFetchOrderBaseViewController:(NSDictionary *)parames {
   
     OrderBaseViewController * VC = [[OrderBaseViewController alloc] init];
     return VC;
     }
   @end
   ```

   ```objective-c
   # import "SNMediator+OrderActions.h"
   
   //Actions中 类‘Target_’之后的硬编码
   NSString * const kSNMediatorTargetOrderAction = @"kOrder";
   
   //Actions中 方法'Action_'之后的硬编码
   NSString * const kSNMediatorActionNativeFetchOrderBasrViewController = @"nativeFetchOrderBaseViewController";
   
   @implementation SNMediator (OrderActions)
   
   - (UIViewController *)SNMediator_viewControllerForOrderBase:(NSDictionary *)params {
   
     UIViewController * viewController = [[SNMediator sharedManager] performTarget:kSNMediatorTargetOrderAction action:kSNMediatorActionNativeFetchOrderBasrViewController params:params shouldCacheTarget:NO];
   
     if ([viewController isKindOfClass:[UIViewController class]]) {
       return viewController;
     } else {
       UIViewController * nullViewController = [UIViewController new];
       [nullViewController.view sn_viewEmpty];
       return nullViewController;
     }
     }
   
   @end
   ```

   ​

## 第三方库

1. 模块内采用手动管理的方式集中在‘vender’中管理。不能使用cocoapods管理，当第三方库出现在了模块中，则说明该第三方库对其他模块意义不大，相反则表明该组件化架构有待优化。
2. 尽量避免在第三方库中修改其源码，有必要时可与源码作者沟通。
3. 在本地导入第三方库前，请参考公共组件模块，避免重复导入造成不必要的麻烦，或者与小组成员谈论该第三方库的可用性。

## 模块内业务代码组织结构

1. 模块内关于业务相关的开发框架没有限制，但是尽量与其它的模块风格保持一致。代码

   1. 目录结构应该是 业务—>框架 的强业务型 如下图：   

      ![屏幕快照 2017-10-27 下午1.50.51](/Users/snlo/Desktop/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-27%20%E4%B8%8B%E5%8D%881.50.51.png)		

    而不是 框架—>业务，如下图：

    ![屏幕快照 2017-10-27 下午4.07.51](/Users/snlo/Desktop/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-27%20%E4%B8%8B%E5%8D%884.07.51.png)	



1. 建议采用XIB而不是storyboard。

2. 创建Controller时采用自定义的snlo touch class，里面有代码管理规范的Mark

   ​

## 编码规范

1. 命名应尽可能遵守Apple命名约定，特别是与[内存管理规则](https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html)（[NARC](http://stackoverflow.com/a/2865194/340508)）有关的命名约定。命名长的，描述性的方法和变量名很好。

2. 对变量属性的命名和声明应该是(采用反命名规则，如应该是buttonSetting而不是settingButton，再如果应该是viewPerson而不是personView)：

   ```objective-c
   @property (nonatomic, strong) UIButton * buttonSetting;
   
   self.buttonSetting;
   
   #pragma mark -- getter / setter
   - (UIButton *)buttonSetting {
       if (!_buttonSetting) {
           _buttonSetting = [UIButton buttonWithType:UIButtonTypeSystem];
       } return _buttonSetting;
   }
   ```

   而不应该是：

   ```objective-c
   @interface StandardViewController () <UITableViewDelegate> {
       UIButton * _setBut;
   }
   
   _setBut;
   ```

3. 注释：当需要它们时，应该使用注释来解释**为什么**特定的代码片段做某事。注释必须保持最新。通常应避免阻止注释，因为代码应尽可能自我记录，只需要间歇的，几行的解释。所有暴露在头文件里面的必须注释。

4. 间距：应该是：

   ```objective-c
   if（user.isHappy）{
      //做某事 
   } else {
      //做别的事情 
   }
   
   //块很容易读取 
   [UIView animateWithDuration:3.0f animations:^{
     // something
   } completion:^(BOOL finished) {
     // something
   }];
   ```

   而不应该是：

   ```objective-c
   if（user.isHappy）{
      //做某事 
   } 
   else {
      //做别的事情 
   }
   
   //块很容易读取 ，不应该提行！
       [UIView animateWithDuration:3.0f
                        animations:^{
                            // something
       }
                        completion:^(BOOL finished) {
                            // something
       }];
   ```

5. 命名优先级（相对本模块）：

   ```objective-c
   object name = module name + developer name + object definition + object attribute;
   ```

   ​

6. 对API的命名要求：
   如果是系统或者第三方库的分类的属性或者接口的命名必须添加类似‘sn_’的前缀。
   其它的应该尽量言简意赅。（可以参考apple的格式）

## 关于

1. 每个模块都将依赖于 ‘SNModuleKit’基础组件模块

